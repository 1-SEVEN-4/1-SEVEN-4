model Group {

string photo "null"
badges BadgeID FK "not null"
recommendations recommendation "not null"
boolean membercount FK "not null"
} 에서 빠진것


**1-8 그룹 참여 (신민수)**

- 닉네임과 비밀번호를 입력하여 그룹에 참여가 가능합니다.
    - 그룹 내에서 중복된 닉네임은 등록 불가합니다.
- 비밀번호 인증을 통해 그룹 참여 취소가 가능하며, 참여를 취소하면 해당 닉네임이 생성한 운동 기록은 모두 삭제됩니다.





Request Body 예시
{
  "nickName": "string",
  "password": "string"
}
​





Response Body 예시
201 CREATED
{
  "id": 0,
  "name": "string",
  "description": "string",
  "photoUrl": "string",
  "goalRep": 0,
  "discordWebhookUrl": "string",
  "discordInviteUrl": "string",
  "likeCount": 0,
  "tags": [
    "string"
  ],
  "owner": {
    "id": 0,
    "nickName": "string",
    "createdAt": 0,
    "updatedAt": 0
  },
  "participants": [
    {
      "id": 0,
      "nickName": "string",
      "createdAt": 0,
      "updatedAt": 0
    }
  ],
  "createdAt": 0,
  "updatedAt": 0,
  "badges": [
    "string"
  ]
}
​
400 BAD REQUEST
{
  "message": "nickName is required"
}



==================== modeling ====================



model User {
  id          Int    @id @default(autoincrement())
  nickName    String @unique
  password    String
  groupId     Int?
  group       Group? @relation(fields: [groupId], references: [id])

  @@index([nickName]) // 닉네임으로 검색할 수 있도록 인덱스 추가
}

model Group {
  id          Int      @id @default(autoincrement())
  name        String
  users       User[]
}



==================== create ====================

import express from 'express';
import { PrismaClient } from '@prisma/client';
import bcrypt from 'bcryptjs'; // 비밀번호 암호화 검증을 위한 bcrypt

const app = express();
const prisma = new PrismaClient();

app.use(express.json()); // 요청 본문을 JSON으로 파싱

// 그룹에 참여하는 API
app.post('/joinGroup', async (req, res) => {
  const { nickName, password, groupId } = req.body;

  // 비밀번호 검증
  const user = await prisma.user.findUnique({
    where: { nickName },
  });

  if (!user || !(await bcrypt.compare(password, user.password))) {
    return res.status(401).json({ message: 'Invalid nickName or password' });
  }

  // 그룹에 사용자가 추가되도록 업데이트
  await prisma.user.update({
    where: { id: user.id },
    data: {
      groupId: groupId, // 그룹에 참여
    },
  });

  res.status(200).json({ message: 'Successfully joined the group' });
});

app.post('/leaveGroup', async (req, res) => {
  const { nickName, password } = req.body;

  // 사용자 정보 가져오기
  const user = await prisma.user.findUnique({
    where: { nickName },
  });

  // 비밀번호 검증
  if (!user || !(await bcrypt.compare(password, user.password))) {
    return res.status(401).json({ message: 'Invalid nickName or password' });
  }



==================== delete ====================



  // 사용자 그룹에서 삭제하고, 해당 사용자의 운동 기록 삭제
  await prisma.user.update({
    where: { id: user.id },
    data: {
      groupId: null, // 그룹에서 나감
    },
  });

  // 운동 기록 삭제 (기록 테이블이 있다고 가정)
  await prisma.record.deleteMany({
    where: {
      userId: user.id,
    },
  });

  res.status(200).json({ message: 'Successfully left the group and deleted records' });
});




    const {
      groupName,
      groupNickname,
      description,
      groupPassword,
      groupPhoto,
      tags,
      goalCount,
      discordInvitationURL,
      discordWebhookURL,
    } = req.body;
    const newdata = await prisma.group.create({
      data: {
        groupName,
        groupNickname,
        description,
        groupPassword,
        groupPhoto,
        tags,
        goalCount,
        discordInvitationURL,
        discordWebhookURL,
      },
    })


    ===========================================================================

    groupRouter
  .route('/:groupId/members')
  .post(validateLoginCondition(), async (req, res) => {
    try {
      const { groupId } = req.params;
      const { nickName, password } = req.body;

      const group = await prisma.group.findUnique({
        where: { id: groupId },
      });

      if (!group) {
        return res.status(404).json({ message: '그룹이 존재하지 않습니다.' });
      }

      const member = await prisma.member.findFirst({
        where: {
          groupId,
          nickName,
        },
      });

      if (member) {
        return res.status(400).json({ message: '이미 존재하는 닉네임입니다.' });
      }

      const newMember = await prisma.member.create({
        data: {
          nickName,
          password,
          groupId,
        },
      });

      return res.status(201).json(newMember);
    } catch (error) {
      console.error('Error deleting member:', error);
      return res.status(500).json({ message: '서버에 문제가 발생했습니다.' });
    } finally {
      console.log('Finished');
    }
  });


  generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Group {
  id            String       @id @default(uuid())
  name          String       @unique
  ownerNickName String       @unique
  ownerPassword String
  description   String
  photo         String?
  tags          String[]
  goalRep       Int
  discordURL    String
  invitationURL String
  likeCount     Int          @default(0)
  createdAt     DateTime     @default(now())
  updatedAt     DateTime     @updatedAt
  memberCount   Int          @default(0)
  badge         Badge?       @relation(fields: [badgeId], references: [badgeId])
  badgeId       String?      @db.Uuid
  groupTags     GroupTags[]
  members       Members[]
  records       Record[]
  GroupBadge    GroupBadge[]
}

model GroupTags {
  id        String   @id @default(uuid())
  content   String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  groupId String @db.Uuid
  groups  Group  @relation(fields: [groupId], references: [id])
}

model Members {
  id        String   @id @default(uuid())
  nickName  String   @unique
  password  String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  groups    Group    @relation(fields: [groupId], references: [id], onDelete: Cascade)
  groupId   String
  records   Record[]
}

model Badge {
  badgeId    String       @id @default(uuid()) @db.Uuid
  member     Boolean      @default(false)
  record     Boolean      @default(false)
  likeCount  Boolean      @default(false)
  createdAt  DateTime     @default(now())
  updatedAt  DateTime     @updatedAt
  memberId   String?      @db.Uuid
  recordId   String?      @db.Uuid
  Group      Group[]
  GroupBadge GroupBadge[]
}

model GroupBadge {
  groupBadgeId String   @id @default(uuid()) @db.Uuid
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  badgeId      String   @db.Uuid
  groupId      String   @db.Uuid
  badge        Badge    @relation(fields: [badgeId], references: [badgeId])
  group        Group    @relation(fields: [groupId], references: [id])
}

model Record {
  id          String   @id @default(uuid())
  sports      Sports
  description String
  time        String
  distance    Int
  photo       String[]
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  groups      Group    @relation(fields: [groupId], references: [id], onDelete: Cascade)
  groupId     String
  members     Members  @relation(fields: [memberId], references: [id], onDelete: Cascade)
  memberId    String
}

enum Sports {
  RUNNING
  CYCLING
  SWIMMING
}
